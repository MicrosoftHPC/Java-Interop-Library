#include "eventwriter.h"

int WriteEvent(int tracelevel, int sessionid, GUID messageid, GUID dispatchid, LPCWSTR msg)
{
	// status is used for the value which win32 API return for status
	int status = ERROR_SUCCESS; 
	
	// EventRegister(): registration handle
	REGHANDLE registrationhandle = NULL; 

	//register
	//the first param is the GUID of the provider generated by the .MAN file in RuntimeEvent.h
	status = EventRegister(
		&RuntimeTrace, 
		NULL,
		NULL,
		&registrationhandle
		);

	if (status != ERROR_SUCCESS)
		return ERROR_REGISTRATIONFAILED;

	//EventWrite(): event data descriptor
	EVENT_DATA_DESCRIPTOR data_descriptor[DATA_DESCRIPTOR_SIZE]; 

	//fill data into the event data descriptor
	int i = 0;
	EventDataDescCreate(&data_descriptor[i++],&sessionid,sizeof(int));
	EventDataDescCreate(&data_descriptor[i++],&messageid,sizeof(GUID));
	EventDataDescCreate(&data_descriptor[i++],&dispatchid,sizeof(GUID));
	EventDataDescCreate(&data_descriptor[i++],msg,(ULONG)(wcslen(msg)+1)*sizeof(WCHAR));

	//choose the trace level
	const EVENT_DESCRIPTOR *event_descriptor;

	switch (tracelevel)
	{
	case LEVEL_VERBOSE:
		event_descriptor = &UserTraceVerbose;
		break;
	case LEVEL_INFO:
		event_descriptor = &UserTraceInfo;
		break;
	case LEVEL_WARNING:
		event_descriptor = &UserTraceWarning;
		break;
	case LEVEL_ERROR:
		event_descriptor = &UserTraceError;
		break;
	case LEVEL_CRITICAL:
		event_descriptor = &UserTraceCritial;
		break;
	default:
		return EVENTWRITER_ERRORINFO_WRONGLEVLE;
		break;
	}

	//write event
	status = EventWrite(
		registrationhandle,
		event_descriptor,
		(ULONG)DATA_DESCRIPTOR_SIZE,
		&data_descriptor[0]
		);

	if (status != ERROR_SUCCESS)
		status = ERROR_WRITEEVENTFAILED;

	//whether it succeeded, we have to unregister the provider
	EventUnregister(registrationhandle);

	//return the status returned by the EventWrite() for checking whether it succeeded
	return status;
}
